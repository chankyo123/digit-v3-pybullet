clear; clc;

%% Import the URDF robot model
robot = importrobot('/Users/ckkim/Chankyo Kim/Michigan/pybullet/urdf/arm-3dof.urdf');
robot.DataFormat = 'column';

%% Set the initial conditions
q0 = [0; 0; 0];  % Initial joint positions
dq0 = [0; 0; 0]; % Initial joint velocities
dt = 0.01;       % Time step size
t_final = 1.0;   % Final time

% Preallocate arrays to store joint positions and velocities
q = zeros(numel(q0), ceil(t_final/dt) + 1);
dq = zeros(numel(dq0), ceil(t_final/dt) + 1);
q(:,1) = q0;
dq(:,1) = dq0;

% Input Torque
array = readtable('/Users/ckkim/Chankyo Kim/Michigan/pybullet/verification/eul-checkJ-1.csv');
array=table2array(array);
time_cp = array(:,end);
tau_cp = array(:,end-4:end-1);
q_cp = array(:,1:4);
dq_cp = array(:,1:4);
tau = [1;1;2];

% Loop through the time steps
for i = 2:ceil(t_final/dt)+1
    % Compute the forward dynamics to obtain acceleration
    acc = robot.forwardDynamics(q(:,i-1), dq(:,i-1), tau);
    
    % Perform backward Euler integration
    dq(:,i) = dq(:,i-1) + dt * acc;  % Update velocity
    q(:,i) = q(:,i-1) + dt * dq(:,i); % Update position
%     disp([size(dt),size(acc),size(dq(:,i-1)),size(q(:,i-1))]);
end

% Plot the joint positions over time
t = 0:dt:t_final;
plot(t, q(1,:), 'r', t, q(2,:), 'g', t, q(3,:), 'b');
xlabel('Time');
ylabel('Joint Position');
legend('Joint 1', 'Joint 2', 'Joint 3');
